<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Canvas Pixel-Grid + Your Drawing</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,sans-serif}
    .wrap{display:grid;gap:12px;padding:12px}
    .panel{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    label{display:inline-flex;gap:6px;align-items:center;font-size:14px}
    input[type="number"]{width:92px;padding:4px 6px}
    input[type="range"]{width:180px}
    button{padding:6px 10px;cursor:pointer}
    canvas{background:#000;border:1px solid #333;image-rendering:pixelated;max-width:100%;height:auto}
    .hint{font-size:13px;opacity:.85}
    code{background:#222;padding:2px 4px;border-radius:4px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <label>Grid W <input id="gridW" type="number" min="1" value="240"></label>
      <label>Grid H <input id="gridH" type="number" min="1" value="280"></label>
      <label>Pixel size <input id="pxSize" type="range" min="1" max="20" value="2"></label>
      <span id="pxSizeVal">2</span>
      <label>Gap <input id="gap" type="range" min="0" max="10" value="1"></label>
      <span id="gapVal">1</span>
      <button id="apply">Apply</button>
      <button id="run">Run drawing</button>
      <span class="hint">Your code uses <code>TO_RGB565(r,g,b)</code>; we convert RGB565 â†’ <code>0xAARRGGBB</code>.</span>
    </div>
    <canvas id="screen"></canvas>
  </div>

<script>
/* -------------------- Pixel-grid display -------------------- */

// Convert 0xAARRGGBB -> CSS rgba()
function argb32ToRgbaCss(color32) {
  const c = (color32 >>> 0);
  const a = (c >>> 24) & 0xFF;
  const r = (c >>> 16) & 0xFF;
  const g = (c >>>  8) & 0xFF;
  const b = (c >>>  0) & 0xFF;
  return `rgba(${r},${g},${b},${(a/255)})`;
}

function clampInt(v, lo, hi) {
  v = v | 0;
  return v < lo ? lo : (v > hi ? hi : v);
}

const display = {
  gridW: 240,
  gridH: 280,
  pixelSize: 16,
  gap: 8,
  bgGapColor: "#000",
  canvas: null,
  ctx: null,

  init(y, x, opts = {}) {
    this.gridH = clampInt(y, 1, 100000);
    this.gridW = clampInt(x, 1, 100000);
    if (typeof opts.pixelSize === "number") this.pixelSize = clampInt(opts.pixelSize, 1, 200);
    if (typeof opts.gap === "number") this.gap = clampInt(opts.gap, 0, 200);

    this.canvas = document.getElementById("screen");
    this.ctx = this.canvas.getContext("2d", { alpha: false });

    const cell = this.pixelSize + this.gap;
    this.canvas.width  = this.gridW * cell;
    this.canvas.height = this.gridH * cell;

    this.clear();
    console.log(`init w:${this.gridW} h:${this.gridH} pixelSize:${this.pixelSize} gap:${this.gap}`);
  },

  clear() {
    this.ctx.fillStyle = this.bgGapColor;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  },

  _cellXY(x, y) {
    const cell = this.pixelSize + this.gap;
    return { cx: x * cell, cy: y * cell };
  },

  _drawPixel(x, y, color32) {
    if (x < 0 || y < 0 || x >= this.gridW || y >= this.gridH) return;
    const { cx, cy } = this._cellXY(x, y);
    this.ctx.fillStyle = argb32ToRgbaCss(color32);
    this.ctx.fillRect(cx, cy, this.pixelSize, this.pixelSize);
  },

  drawFastHLine(x, y, w, color32) {
    x |= 0; y |= 0; w |= 0;
    if (w <= 0) return;

    const x0 = Math.max(0, x);
    const x1 = Math.min(this.gridW, x + w);
    if (y < 0 || y >= this.gridH || x0 >= x1) return;

    for (let i = x0; i < x1; i++) this._drawPixel(i, y, color32);
  },

  drawFastVLine(x, y, h, color32) {
    x |= 0; y |= 0; h |= 0;
    if (h <= 0) return;

    const y0 = Math.max(0, y);
    const y1 = Math.min(this.gridH, y + h);
    if (x < 0 || x >= this.gridW || y0 >= y1) return;

    for (let j = y0; j < y1; j++) this._drawPixel(x, j, color32);
  },

  fillRect(x, y, w, h, color32) {
    x |= 0; y |= 0; w |= 0; h |= 0;
    if (w <= 0 || h <= 0) return;

    const x0 = Math.max(0, x);
    const y0 = Math.max(0, y);
    const x1 = Math.min(this.gridW, x + w);
    const y1 = Math.min(this.gridH, y + h);
    if (x0 >= x1 || y0 >= y1) return;

    for (let yy = y0; yy < y1; yy++) {
      for (let xx = x0; xx < x1; xx++) this._drawPixel(xx, yy, color32);
    }
  },

  drawRect(x, y, w, h, color32) {
    x |= 0; y |= 0; w |= 0; h |= 0;
    if (w <= 0 || h <= 0) return;

    this.drawFastHLine(x, y, w, color32);
    this.drawFastHLine(x, y + h - 1, w, color32);
    this.drawFastVLine(x, y, h, color32);
    this.drawFastVLine(x + w - 1, y, h, color32);
  }
};

/* -------------------- RGB565 bridge -------------------- */

// Your code produces "RGB565". We convert it to 32-bit ARGB for the canvas display.
// (Keeps your calling style unchanged.)
function RGB565_to_ARGB8888(rgb565) {
  rgb565 = rgb565 & 0xFFFF;
  const r5 = (rgb565 >> 11) & 0x1F;
  const g6 = (rgb565 >>  5) & 0x3F;
  const b5 = (rgb565 >>  0) & 0x1F;

  // Expand to 8-bit (common bit replication)
  const r8 = (r5 << 3) | (r5 >> 2);
  const g8 = (g6 << 2) | (g6 >> 4);
  const b8 = (b5 << 3) | (b5 >> 2);

  return (0xFF << 24) | (r8 << 16) | (g8 << 8) | (b8 << 0);
}

// Pack 8-bit r,g,b -> RGB565 (returns 0..65535)
function TO_RGB565(r, g, b) {
  r = clampInt(r, 0, 255);
  g = clampInt(g, 0, 255);
  b = clampInt(b, 0, 255);
  const r5 = (r >> 3) & 0x1F;
  const g6 = (g >> 2) & 0x3F;
  const b5 = (b >> 3) & 0x1F;
  return (r5 << 11) | (g6 << 5) | (b5);
}

// Wrap display methods so they accept your RGB565 colors directly:
const hw = {
  drawFastHLine: (x,y,w,c565) => display.drawFastHLine(x,y,w, RGB565_to_ARGB8888(c565)),
  drawFastVLine: (x,y,h,c565) => display.drawFastVLine(x,y,h, RGB565_to_ARGB8888(c565)),
  fillRect:      (x,y,w,h,c565) => display.fillRect(x,y,w,h, RGB565_to_ARGB8888(c565)),
  drawRect:      (x,y,w,h,c565) => display.drawRect(x,y,w,h, RGB565_to_ARGB8888(c565)),
};

/* -------------------- Your drawing code -------------------- */





function runYourDrawing()
{
  display.clear();

  var topY      = 163;
  var bodyW = new Uint8Array([8,8]);
  var bodyH     = 76;
  var keyO      = 0;

  var wk_halfW = bodyW[0] >> 1;
  var bk_halfW = bodyW[1] >> 1;
  var bodyH1  = (bodyH - 2) * 2/3;
  var bodyH2  = (bodyH - 2) * 1/3;

  var cWBody = TO_RGB565(255,255,255);
  var cBBody = TO_RGB565(0,0,0);
  var cTopA = TO_RGB565(197,197,197);
  var cEdgA = TO_RGB565(255,0,0);  //TO_RGB565(220,220,220);
  var cSepA = TO_RGB565(175,175,175);
  var c0,c1;
  var y0,y1;
  var xOffs;

  // TYPE 1 WHITE
  xOffs = 0;
  
  hw.drawFastHLine(xOffs+1, topY , wk_halfW-keyO, cTopA);                            // H top-anti
  hw.drawFastVLine(xOffs, topY , bodyH, cEdgA);                                      // V left-anti
  hw.drawFastVLine(xOffs+wk_halfW-keyO+1, topY , bodyH1+2, cEdgA);                   // V right1-anti R
  hw.drawFastHLine(xOffs+wk_halfW-keyO+2, topY+bodyH1+1 ,bk_halfW+keyO , cEdgA);     // H mid-anti R
  hw.drawFastVLine(xOffs+bodyW[0]+1, topY+bodyH1+1 , bodyH2+2, cEdgA);               // V right2-anti
  hw.drawFastHLine(xOffs+1, topY+bodyH-1 ,bodyW[0] , cTopA);                         // H botom-anti

  hw.fillRect(xOffs+1, topY+1, wk_halfW-keyO, bodyH1+1 , cWBody);                    // body1
  hw.fillRect(xOffs+1, topY+bodyH1+2, bodyW[0], bodyH2 , cWBody);                    // body2

  // SEPARATION
  hw.drawFastVLine(xOffs+bodyW[0]+2, topY+bodyH1+1 , bodyH2+2, cSepA);                 // V separation

  // BLACK
  xOffs += wk_halfW;

  hw.drawFastHLine(xOffs-keyO+2, topY , bodyW[1]+2, cTopA);                          // H top-anti
  hw.drawRect(xOffs-keyO+2, topY+1 , bodyW[1]-2 , bodyH1, cBBody );                     // SQ body
  c0 = 20; c1 = 150;
  y0 = topY+2; y1= topY+bodyH1-1;
  for(var i=y0;i<y1;i++)
  {
      var cVal = c0 + ((i-y0+1)/(y1-y0)) * (c1-c0);
      var cGrad = TO_RGB565(cVal,cVal,cVal);
      hw.drawFastHLine(xOffs+3-keyO, i , bodyW[1] , cGrad);                          // H gradient
  }


  // TYPE 2 WHITE
  xOffs += wk_halfW+3;
  hw.drawFastHLine(xOffs+bodyW[1]-keyO+1, topY , bodyW[0], cTopA);                     // H top-anti

    hw.drawFastVLine(xOffs+wk_halfW-keyO+1, topY , bodyH1+3, cEdgA);                   // V left1-anti
  hw.drawFastVLine(xOffs+bodyW[1]-keyO+1, topY , bodyH1+2, cEdgA);                   // V right1-anti

  //hw.drawFastHLine(xOffs, topY+bodyH1+1 ,wk_halfW-2-keyO , cEdgA);                   // H mid-anti L
  //hw.drawFastHLine(xOffs+wk_halfW-keyO+2, topY+bodyH1+1 ,wk_halfW-4+keyO , cEdgA);   // H mid-anti R
  //hw.drawFastVLine(xOffs, topY+bodyH1+1, bodyH2+2, cEdgA);                           // V left2-anti
  //hw.drawFastVLine(xOffs+wk_halfW+1+bodyW2, topY+bodyH1+1 , bodyH2+2, cEdgA);        // V right2-anti
  //hw.drawFastHLine(xOffs+1, topY+bodyH-1 ,bodyW[0] , cTopA);                         // H bottom-anti
  
  hw.fillRect(xOffs+wk_halfW-keyO+2, topY+1,  (xOffs+wk_halfW-keyO+3) - (xOffs+wk_halfW-keyO)  , bodyH1+1 , cWBody);  // body1
  hw.fillRect(xOffs+1, topY+bodyH1+2, bodyW[0], bodyH2 , cWBody);                  // body2


  // SEPARATION
  hw.drawFastVLine(xOffs+bodyW[0]+2, topY+bodyH1+1 , bodyH2+2, cSepA);                 // V separation

  /*
  // BLACK
  xOffs += wk_halfW;
  hw.drawFastHLine(xOffs+2, topY , wk_halfW+1+1, cTopA);                       // H top-anti
  hw.drawRect(xOffs+2, topY+1 , wk_halfW+1+1 , bodyH1, cBBody );               // SQ body
  c0 = 1; c1 = 150;
  y0 = topY+1; y1= topY+bodyH1-1;
  for(var i=y0;i<y1;i++)
  {
      var cVal = ((i-y0+1)/(y1-y0)) * (c1-c0);
      var cGrad = TO_RGB565(cVal,cVal,cVal);
      hw.drawFastHLine(xOffs+1+2, i , wk_halfW+1-1 , cGrad);                     // H gradient
  }

  // TYPE 3 WHITE
  xOffs += wk_halfW;
  hw.drawFastHLine(xOffs+bodyW2+1, topY , bodyW[0]-wk_halfW+2, cTopA);            // H top-anti
  hw.drawFastVLine(xOffs+bodyW2, topY , bodyH1+1, cEdgA);                  // V left1-anti
  hw.drawFastVLine(xOffs+bodyW[0]-bodyW2, topY , bodyH1+2, cEdgA);          // V right1-anti

  hw.drawFastHLine(xOffs, topY+bodyH1+1 ,bodyW2+1 , cEdgA);                // H mid-anti L
  hw.drawFastHLine(xOffs+bodyW[0]-bodyW2, topY+bodyH1+1 ,bodyW2+1 , cEdgA); // H mid-anti R
  hw.drawFastVLine(xOffs, topY+bodyH1+1, bodyH2+1, cEdgA);                 // V left2-anti
  hw.drawFastVLine(xOffs+wk_halfW+1+bodyW2, topY+bodyH1+2 , bodyH2+2, cEdgA);  // V right2-anti
  hw.drawFastHLine(xOffs+1, topY+bodyH-1 ,bodyW[0]-2 , cTopA);                // H botom-anti

  hw.fillRect(xOffs+bodyW2+1, topY+1, bodyW[0]-bodyW2-3, bodyH1+1 , cWBody);  // body1
  hw.fillRect(xOffs+1, topY+bodyH1+2, bodyW[0]-2, bodyH2 , cWBody);                 // body2
*/
}

/* -------------------- UI wiring -------------------- */

const gridWEl = document.getElementById("gridW");
const gridHEl = document.getElementById("gridH");
const pxSizeEl = document.getElementById("pxSize");
const gapEl = document.getElementById("gap");
const pxSizeVal = document.getElementById("pxSizeVal");
const gapVal = document.getElementById("gapVal");

function applySettings() {
  const gw = parseInt(gridWEl.value, 10) || 240;
  const gh = parseInt(gridHEl.value, 10) || 280;
  const ps = parseInt(pxSizeEl.value, 10) || 2;
  const gp = parseInt(gapEl.value, 10) || 1;
  display.init(gh, gw, { pixelSize: ps, gap: gp });
}

pxSizeEl.addEventListener("input", () => pxSizeVal.textContent = pxSizeEl.value);
gapEl.addEventListener("input", () => gapVal.textContent = gapEl.value);

document.getElementById("apply").addEventListener("click", () => applySettings());
document.getElementById("run").addEventListener("click", () => runYourDrawing());

// Default init + auto-run
applySettings();
runYourDrawing();
</script>
</body>
</html>
